/*
 * generated by Xtext 2.24.0
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.mydsl.myDsl.Contract
import org.xtext.example.mydsl.myDsl.ContractCancellationTerm
import org.xtext.example.mydsl.myDsl.ClaimReductionTerm
import org.xtext.example.mydsl.myDsl.PremiumIncreaseTerm
import org.xtext.example.mydsl.myDsl.ContractType

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyDslGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.contents.head as Contract
		fsa.generateFile(resource.targetFileName, model.doGenerate)
	}
	
	def String getTargetFileName(Resource resource) {
		val originalFileName = resource.URI.lastSegment;
		originalFileName.substring(0, originalFileName.indexOf(".")) + ".sol";
	}
	
	//TODO handle default values for not provided attributes
	def String doGenerate(Contract contract) {
		'''
		// SPDX-License-Identifier: GPL-3.0
		pragma solidity >=0.7.0 <0.9.0;
		
		contract «contract.name» {
			
			«val companyAddress = contract.company.name»
			«val insurableObjects = contract.insurableObjects»
			«val premium = contract.paymentTerm.premium»
			«val premiumIncrease = contract.paymentTerm.increase»
			«val claim = contract.claimTerm.claim»
			«val paymentPeriod = contract.paymentTerm.period»
			
			«IF contract.customers.size == 1»
				«val customerAddress = contract.customers.get(0).name»
				address public customer = «customerAddress»;
			«ELSE»
				address[] public customerAddresses = [«contract.customers.map[name].join(",")»]
			«ENDIF»
			address public company = «companyAddress»;			
			
			
			uint256 public paymentPeriod = «paymentPeriod»;
			uint256 public premiumIncrease = «premiumIncrease»;			
			uint256 public claimAmount = «claim»;			
			uint256 public premiumAmount = «premium»;			
			uint256 public lastPayment;
			uint256 public numClaims;			
			
			enum ContractState { ACTIVE, INACTIVE, BLOCKED }
			ContractState public contractState;
						
			«contract.generateConstructor»
			
			«contract.generatePremiumPaymentFunction»
						
			«contract.generateClaimFunction»
			
			«generateGetPremium()»
			
			«generateGetClaim()»
			
		}
		'''
	}


	//TODO initialize violation variables and create corresponding methods to alter them
	dispatch def String handleViolationTerms(ContractCancellationTerm violationTerm){
		'''
		if(lastPayment + paymentPeriod < block.timestamp) {
            contractState = ContractState.BLOCKED;
        }
		'''
	}
	
	dispatch def String handleViolationTerms(ClaimReductionTerm violationTerm){
		'''
		if(lastPayment + paymentPeriod < block.timestamp) {
            claimAmount = claimAmount * (100 - «violationTerm.claimReduction»)/100;
        }
		'''
	}
	
	dispatch def String handleViolationTerms(PremiumIncreaseTerm violationTerm){
		'''
		if(lastPayment + paymentPeriod < block.timestamp) {
            premiumAmount = premiumAmount * (100 + «violationTerm.premiumIncrease»)/100;
        }
		'''
	}


	//TODO dynamically create method bodies based on contract type
	def String generateConstructor(Contract contract){
		
		val signature_start = "constructor() public payable {\n"
		val signature_end = "\n}\n"	
		
		var body = 	
			switch(contract.type) {		 
				case ContractType.PERSONAL : getContructorPersonal(contract)
				case ContractType.FAMILY : getContructorFamily(contract)					
				case ContractType.POOL : getContructorPool(contract)					
				default : ""			
			}
		
		return signature_start.concat(body).concat(signature_end);
	}
	
	
	def String generatePremiumPaymentFunction(Contract contract){
					
		val signature_start = "function pay() public payable {\n"
		val signature_end = "\n}\n"	
		
		val violationTerms = contract.violationTerms.map[handleViolationTerms].join("\n")
		
		var body = 	
			switch(contract.type) {		 
				case ContractType.PERSONAL : generatePremiumFunctionPersonal(contract)
				case ContractType.FAMILY : generatePremiumFunctionFamily(contract)					
				case ContractType.POOL : generatePremiumFunctionPool(contract)					
				default : ""			
			}
		
		return signature_start.concat(violationTerms).concat(body).concat(signature_end);
	}
	
	def String generateClaimFunction(Contract contract){
		
		val signature_start = "function claim() public payable {\n"
		val signature_end = "\n}\n"	
		
		var body = 	
			switch(contract.type) {		 
				case ContractType.PERSONAL : generateClaimFunctionPersonal(contract)
				case ContractType.FAMILY : generateClaimFunctionFamily(contract)					
				case ContractType.POOL : generateClaimFunctionPool(contract)					
				default : ""			
			}
		
		return signature_start.concat(body).concat(signature_end);
	}
	
	def String getContructorPersonal(Contract contract){
		'''
		numClaims = 0;
        lastPayment = block.timestamp;
        contractState = ContractState.INACTIVE;					
		'''
	}
	
	def String getContructorFamily(Contract contract){

		'''
		require(msg.value == getPremium1(customerAddress));
		lastPayment = now;					
		'''
	}
	
	def String getContructorPool(Contract contract){
		'''
		require(msg.value == getPremium1(customerAddress));
		lastPayment = now;					
		'''
	}
	
	
	
	def String generatePremiumFunctionPersonal(Contract contract){
		'''
		require(contractState != ContractState.BLOCKED, "The contract has been blocked due to late payment.");
		        
        require(msg.sender == customer, "Only the contract owner can pay");
               
        require(msg.value == getPremium(), "Incorrect premium. Invoke the getPremium function to see the required amount");
        
        company.transfer(msg.value);
        
        contractState = ContractState.ACTIVE;
        
        lastPayment = block.timestamp;				
		'''
	}
	
	def String generatePremiumFunctionFamily(Contract contract){

		'''
		require(msg.value == getPremium1(customerAddress));
		lastPayment = now;					
		'''
	}
	
	def String generatePremiumFunctionPool(Contract contract){
		'''
		require(msg.value == getPremium1(customerAddress));
		lastPayment = now;					
		'''
	}
	
	
	def String generateClaimFunctionPersonal(Contract contract){
		'''
		
        require(contractState == ContractState.ACTIVE, "Premium payment required. Only an active contract can be claimed");
        
        require(msg.sender == company, "Claims can only be initiated by the insurer");
        
        require(msg.value == claimAmount, "Incorrect claim. Invoke the getClaim function to see the required amount");
        
        customer.transfer(claimAmount);

        numClaims++;			
		'''
	}
	
	def String generateClaimFunctionFamily(Contract contract){

		'''
		require(msg.value == getPremium1(customerAddress));
		lastPayment = now;					
		'''
	}
	
	def String generateClaimFunctionPool(Contract contract){
		'''
		require(msg.value == getPremium1(customerAddress));
		lastPayment = now;					
		'''
	}
	
	def String generateGetPremium(){
		'''
		function getPremium() public view returns (uint256 premium) {
	        return ((premiumIncrease * numClaims)/100 + 1) * premiumAmount;
	    }
		'''
	}
	
	def String generateGetClaim(){
		'''
	 	function getClaim() public view returns (uint256 the_claim) {
	        return claimAmount;
	    }
		'''
	}
	
	
	
	
}
