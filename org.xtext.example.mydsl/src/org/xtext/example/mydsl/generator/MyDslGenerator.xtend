/*
 * generated by Xtext 2.24.0
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.mydsl.myDsl.Contract
import org.xtext.example.mydsl.myDsl.ContractCancellationTerm
import org.xtext.example.mydsl.myDsl.ClaimReductionTerm
import org.xtext.example.mydsl.myDsl.PremiumIncreaseTerm
import org.xtext.example.mydsl.myDsl.ContractType

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyDslGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.contents.head as Contract
		fsa.generateFile(resource.targetFileName, model.doGenerate)
	}
	
	def String getTargetFileName(Resource resource) {
		val originalFileName = resource.URI.lastSegment;
		originalFileName.substring(0, originalFileName.indexOf(".")) + ".sol";
	}
	
	//TODO handle default values for not provided attributes
	def String doGenerate(Contract contract) {
		'''
		pragma solidity ^0.4.15
		
		contract «contract.name» {
			
			«val companyAddress = contract.company.name»
			«val insurableObjects = contract.insurableObjects»
			«val premium = contract.paymentTerm.premium»
			«val premiumIncrease = contract.paymentTerm.increase»
			«val claim = contract.claimTerm.claim»
			«val paymentPeriod = contract.paymentTerm.period»
			
			address public companyAddress = «companyAddress»;			
			uint256 public premium = «premium»;			
			uint256 public premiumIncrease = «premiumIncrease»;			
			uint256 public claim = «claim»;			
			uint256 public paymentPeriod = «paymentPeriod»;
			
			uint256 public numAccidents = 0;			
			uint256 public lastPayment;
			
			«IF contract.customers.size == 1»
			«val customerAddress = contract.customers.get(0).name»
			address public customerAddress = «customerAddress»;
			«ELSE»
			address[] public customerAddresses = [«contract.customers.map[name].join(",")»]
			«ENDIF»
						
			«contract.generateConstructor»
			
			«contract.generatePremiumFunction»
			
			«contract.generatePaymentFunction»
			
			«contract.generateClaimFunction»
			
			«contract.violationTerms.map[handleViolationTerms].join("\n")»
			
		}
		'''
	}


	//TODO initialize violation variables and create corresponding methods to alter them
	dispatch def String handleViolationTerms(ContractCancellationTerm violationTerm){
		'''Dummy text'''
	}
	
	dispatch def String handleViolationTerms(ClaimReductionTerm violationTerm){
		'''Dummy text'''
	}
	
	dispatch def String handleViolationTerms(PremiumIncreaseTerm violationTerm){
		'''Dummy text'''
	}


	//TODO dynamically create method bodies based on contract type
	def String generateConstructor(Contract contract){
		
		val signature_start = "constructor() public payable {\n"
		val signature_end = "\n}\n"	
		
		var body = 	
			switch(contract.type) {		 
				case ContractType.PERSONAL : getContructorPersonal(contract)
				case ContractType.FAMILY : getContructorFamily(contract)					
				case ContractType.POOL : getContructorPool(contract)					
				default : ""			
			}
		
		return signature_start.concat(body).concat(signature_end);
	}
	
	
	def String getContructorPersonal(Contract contract){
		'''
		require(msg.value == getPremium1(customerAddress));
		lastPayment = now;					
		'''
	}
	
	def String getContructorFamily(Contract contract){
		'''
		require(msg.value == getPremium1(customerAddress));
		lastPayment = now;					
		'''
	}
	def String getContructorPool(Contract contract){
		'''
		require(msg.value == getPremium1(customerAddress));
		lastPayment = now;					
		'''
	}
	
	
	def String generatePremiumFunction(Contract contract){
		'''
		function getPremium(address customer) constant public returns (uint256 premium) {
			return ((numAccidents * premiumIncrease) + 1) * premium;
		}
		'''
	}
	
	def String generatePaymentFunction(Contract contract){
		'''
		function pay() public payable {
			require(msg.sender == customerAddress);
			require(msg.value == getPremium(customerAddress));
			companyAddress.transfer(msg.value)
			lastPayment = now;
		}
		'''
	}
	
	def String generateClaimFunction(Contract contract){
		'''
		function claim() public payable {
			customerAddress.transfer(claim);
			numAccidents++;
		}
		'''
	}
	
}
